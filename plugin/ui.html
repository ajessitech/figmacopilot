<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fray - Figma Copilot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        font-size: 14px;
        color: #333;
        background: #f9fafb;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Chat Container */
      .chat-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px 24px;
        display: flex;
        flex-direction: column;
        background: #f9fafb;
        min-height: 0;
        scroll-behavior: smooth;
      }

      .chat-container::-webkit-scrollbar {
        width: 6px;
      }

      .chat-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .chat-container::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 3px;
      }

      /* Messages */
      .message {
        display: flex;
        animation: slideIn 0.3s ease-out;
        margin-bottom: 20px;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.user {
        justify-content: flex-end;
      }

      .message.assistant {
        justify-content: flex-start;
      }

      .message-content {
        line-height: 1.6;
        word-wrap: break-word;
      }

      /* User messages with bubble */
      .message.user .message-content {
        max-width: 75%;
        padding: 10px 14px;
        background: rgb(255, 120, 71);
        color: white;
        border-radius: 18px;
        border-bottom-right-radius: 4px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      /* Assistant messages without bubble - full width */
      .message.assistant .message-content {
        width: 100%;
        color: #1f2937;
        padding: 0;
        background: transparent;
        border: none;
        box-shadow: none;
      }

      /* Status indicator - minimal inline system style */
      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        margin: 8px 0;
        background: transparent;
        border-radius: 0;
        box-shadow: none;
        animation: slideInFade 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        transition: opacity 0.2s ease;
      }

      .status-indicator .spinner {
        width: 14px;
        height: 14px;
        min-width: 14px;
        border: 2px solid rgba(255, 120, 71, 0.25);
        border-top-color: rgb(255, 120, 71);
        border-radius: 50%;
        animation: spin 0.9s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }

      .status-indicator .status-text {
        color: #6b7280;
        font-size: 14px;
        font-weight: 500;
        letter-spacing: -0.01em;
        animation: fadeIn 0.3s ease-out;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .status-indicator .status-icon {
        font-size: 16px;
        line-height: 1;
      }

      @keyframes slideInFade {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Typing indicator */
      .typing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 8px 12px;
      }

      .typing-indicator span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: rgb(255, 120, 71);
        animation: typing 1.4s infinite;
      }

      .typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typing {
        0%, 60%, 100% {
          transform: translateY(0);
          opacity: 0.7;
        }
        30% {
          transform: translateY(-10px);
          opacity: 1;
        }
      }

      /* Welcome Message */
      .welcome-message {
        text-align: center;
        padding: 40px 20px;
        color: #666;
      }

      .welcome-message h2 {
        color: #333;
        margin-bottom: 12px;
        font-size: 20px;
      }

      .welcome-message p {
        line-height: 1.6;
        margin-bottom: 16px;
      }

      .tips {
        background: white;
        border: 1px solid #e5e5e5;
        border-radius: 8px;
        padding: 12px;
        text-align: left;
        font-size: 13px;
      }

      .tips h3 {
        color: rgb(255, 120, 71);
        margin-bottom: 10px;
        font-size: 15px;
        font-weight: 600;
      }

      .tips ul {
        list-style: none;
        padding-left: 0;
      }

      .tips li {
        padding: 4px 0;
        padding-left: 20px;
        position: relative;
      }

      .tips li::before {
        content: 'âœ¨';
        position: absolute;
        left: 0;
      }

      /* Input Area - Floating Style */
      .input-area {
        padding: 16px 24px 20px 24px;
        background: #f9fafb;
        flex-shrink: 0;
      }

      .input-container {
        max-width: 100%;
        margin: 0 auto;
        position: relative;
      }

      .input-wrapper {
        position: relative;
        background: #ffffff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 24px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        transition: all 0.2s ease;
      }

      .input-wrapper:hover {
        border-color: rgba(0, 0, 0, 0.12);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      }

      .input-wrapper:focus-within {
        border-color: rgba(255, 120, 71, 0.5);
        box-shadow: 0 2px 8px rgba(255, 120, 71, 0.1);
      }

      .input-field {
        width: 100%;
        min-height: 52px;
        max-height: 200px;
        padding: 14px 52px 14px 20px;
        border: none;
        background: transparent;
        resize: none;
        font-family: inherit;
        font-size: 15px;
        line-height: 1.6;
        color: #1f2937;
        overflow-y: auto;
      }

      .input-field:focus {
        outline: none;
      }

      .input-field::placeholder {
        color: #9ca3af;
        font-weight: 400;
        font-size: 15px;
      }

      .input-field:disabled {
        background: transparent;
        cursor: not-allowed;
        color: #9ca3af;
      }

      .input-field::-webkit-scrollbar {
        width: 6px;
      }

      .input-field::-webkit-scrollbar-track {
        background: transparent;
      }

      .input-field::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 3px;
      }

      .input-field::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
      }

      .send-button {
        position: absolute;
        right: 10px;
        bottom: 50%;
        transform: translateY(50%) scale(0.9);
        width: 36px;
        height: 36px;
        border: none;
        background: rgb(255, 120, 71);
        color: white;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        opacity: 0;
        pointer-events: none;
      }

      .input-wrapper.has-content .send-button {
        opacity: 1;
        transform: translateY(50%) scale(1);
        pointer-events: auto;
      }

      .send-button:hover:not(:disabled) {
        background: rgb(235, 100, 51);
        transform: translateY(50%) scale(1.1);
      }

      .send-button:active:not(:disabled) {
        transform: translateY(50%) scale(0.95);
      }

      .send-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        pointer-events: none;
      }

      .send-button svg {
        width: 18px;
        height: 18px;
        stroke-width: 2.5;
      }

      .char-counter {
        position: absolute;
        right: 48px;
        bottom: 14px;
        font-size: 11px;
        color: #9ca3af;
        display: none;
      }

      .input-wrapper.show-counter .char-counter {
        display: block;
      }

      .error-banner {
        background: #ffebee;
        color: #c62828;
        padding: 12px;
        border-radius: 6px;
        margin: 16px;
        margin-bottom: 0;
        display: none;
        animation: slideIn 0.3s ease-out;
        flex-shrink: 0;
      }

      .error-banner.show {
        display: block;
      }

      /* New Chat (+) button */
      .new-chat-btn {
        position: absolute;
        top: 10px;
        right: 12px;
        width: 28px;
        height: 28px;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
        background: #ffffff;
        color: #6b7280;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        transition: background 0.15s ease, color 0.15s ease, transform 0.05s ease;
        user-select: none;
        z-index: 10;
      }

      .new-chat-btn:hover {
        background: #f9fafb;
        color: #374151;
      }

      .new-chat-btn:active {
        transform: translateY(1px);
      }
    </style>
  </head>
  <body>
    <button class="new-chat-btn" id="newChatBtn" title="New chat">+</button>
    <div class="error-banner" id="errorBanner"></div>

    <div class="chat-container" id="chatContainer">
      <div class="welcome-message" id="welcomeMessage">
        <h2>Welcome to Fray! ðŸ‘‹</h2>
        <p>I'm your AI-powered design assistant. Select elements in your Figma design and ask me questions about them.</p>
        <div class="tips">
          <h3>Try asking:</h3>
          <ul>
            <li>What are the dimensions of this frame?</li>
            <li>What colors are used in this selection?</li>
            <li>Describe the visual hierarchy</li>
            <li>What font is being used here?</li>
          </ul>
          </div>
        </div>
      </div>

    <div class="input-area">
      <div class="input-container">
        <div class="input-wrapper" id="inputWrapper">
          <textarea 
            class="input-field" 
            id="inputField" 
            placeholder="Message Fray..."
            rows="1"
            disabled
          ></textarea>
          <button class="send-button" id="sendButton" disabled>
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75"></path>
            </svg>
          </button>
          
          <span class="char-counter" id="charCounter"></span>
        </div>
      </div>
    </div>

    <script>
      // Connection state
      const state = {
        connected: false,
        socket: null,
        serverPort: 3055,
        channel: null,
      };

      // Selections context cache
      const snapshotCache = {
        document: null, // { pageId, pageName }
        last: null,      // { selectionSignature, selectionSummary, document, ts }
        latestSig: null,
        lastSnapshot: null // { snapshot, mode, ts }
      };
      const SNAPSHOT_TTL_MS = 60000;
      const DEFAULT_SELECTIONS_MODE = 'complete'; // 'snapshot' | 'complete'

      // Reconnect/heartbeat config
      const HEARTBEAT_INTERVAL = 30000; // 30s
      const BASE_RECONNECT_DELAY = 3000; // 3s
      const MAX_RECONNECT_DELAY = 60000; // 60s
      const MAX_RECONNECT_ATTEMPTS = 7;
      let heartbeatTimer = null;
      let reconnectAttempts = 0;
      let reconnectTimer = null;
      let intentionalClose = false;
      let isConnecting = false;

      // DOM Elements
      let chatContainer, inputField, sendButton, errorBanner, welcomeMessage, inputWrapper, charCounter;

      // Streaming state
      let currentStreamingContentEl = null;
      let acceptingStream = false;
      let streamedAnyChunks = false;
      let startNewAssistantBlockAfterTool = false;
      let uiStartTs = Date.now();

      // Status messages
      const statusMessages = {
        thinking: ['Thinking...', 'Working on it...', 'Considering your request...', 'Processing your idea...'],
        generating: ['Writing response...', 'Crafting your answer...', 'Putting it together...', 'Almost there...']
      };

      function getStatusMessage(category) {
        const messages = statusMessages[category];
        if (!messages) return 'Processing...';
        return messages[Math.floor(Math.random() * messages.length)];
      }

      document.addEventListener('DOMContentLoaded', () => {
        chatContainer = document.getElementById('chatContainer');
        inputField = document.getElementById('inputField');
        sendButton = document.getElementById('sendButton');
        errorBanner = document.getElementById('errorBanner');
        welcomeMessage = document.getElementById('welcomeMessage');
        inputWrapper = document.getElementById('inputWrapper');
        charCounter = document.getElementById('charCounter');

        // Events
        sendButton.addEventListener('click', handleSend);
        inputField.addEventListener('keydown', handleKeyDown);
        inputField.addEventListener('input', handleInputChange);
        if (errorBanner) {
          errorBanner.addEventListener('click', () => {
            try { cleanupConnection('manual-retry'); } catch (_) {}
            if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
            reconnectAttempts = 0;
            isConnecting = false;
            hideError();
            updateConnectingUI('Reconnectingâ€¦');
            connectToServer(state.serverPort);
          });
        }

        // Auto-connect on load
        updateConnectingUI('Connecting to bridge...');
        connectToServer(state.serverPort);
        // Close socket on UI unload to avoid stale sessions
        window.addEventListener('beforeunload', () => cleanupConnection('unload'));

        // Notify plugin UI is ready (document info only; no selection traffic)
        try {
          parent.postMessage({ pluginMessage: { type: 'ui_ready' } }, '*');
        } catch (e) {
          console.warn('Failed to send ui_ready to plugin', e);
        }
        // New Chat button
        const newChatBtn = document.getElementById('newChatBtn');
        if (newChatBtn) newChatBtn.addEventListener('click', handleNewChat);
      });

      // UI helpers
      function addMessage(type, content) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message ' + (type === 'user' ? 'user' : 'assistant');

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.textContent = content || '';

        messageDiv.appendChild(contentDiv);
        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        return contentDiv;
      }

      function showStatusIndicator(text = 'Processing...') {
        removeStatusIndicator(true);
        const statusDiv = document.createElement('div');
        statusDiv.className = 'status-indicator';
        statusDiv.id = 'statusIndicator';

        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        const statusText = document.createElement('div');
        statusText.className = 'status-text';
        statusText.textContent = text;

        statusDiv.appendChild(spinner);
        statusDiv.appendChild(statusText);
        chatContainer.appendChild(statusDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      function clearChatUI() {
        // Remove all chat message nodes but keep the welcome message node
        try {
          const children = Array.from(chatContainer.children);
          for (const el of children) {
            if (el.id !== 'welcomeMessage') {
              chatContainer.removeChild(el);
            }
          }
          if (welcomeMessage) {
            welcomeMessage.style.display = 'block';
          }
        } catch (_) {}
        // Reset streaming state
        currentStreamingContentEl = null;
        acceptingStream = false;
        streamedAnyChunks = false;
        startNewAssistantBlockAfterTool = false;
        removeStatusIndicator(true);
      }

      function handleNewChat() {
        // Reset local caches/state
        snapshotCache.last = null;
        snapshotCache.latestSig = null;
        snapshotCache.lastSnapshot = null;
        clearChatUI();
        // Tell the agent to clear its session memory
        try {
          if (state.connected && state.socket && state.socket.readyState === WebSocket.OPEN) {
            state.socket.send(JSON.stringify({ type: 'new_chat' }));
          }
        } catch (_) {}
      }

      

      function removeStatusIndicator(immediate = false) {
        const el = document.getElementById('statusIndicator');
        if (!el) return;
        if (immediate) {
          el.remove();
          return;
        }
        el.style.opacity = '0';
        el.style.transition = 'opacity 0.2s ease-out';
        setTimeout(() => el.remove(), 200);
      }

      // Tool status lines handling
      const toolStatusLines = new Map(); // id -> { el, spinnerEl, textEl, iconEl, command, type }
      let contextGroup = null; // { line: {...}, pendingIds: Set<string>, failed: boolean, open: boolean }

      const TOOL_COPY_OVERRIDES = {
        'gather_context': 'Gathering contextâ€¦',
        'get_selection_context': 'Gathering contextâ€¦',
        'get_selection_snapshot': 'Capturing selection snapshotâ€¦',
        'scan_text_nodes': 'Scanning textâ€¦',
        'scan_nodes': 'Scanning layersâ€¦',
        'scan_styles': 'Scanning stylesâ€¦',
        'measure_layout': 'Measuring layoutâ€¦',
        'update_colors': 'Updating colorsâ€¦',
        'apply_color_updates': 'Updating colorsâ€¦'
      };

      const CONTEXT_TOOL_HINTS = ['context', 'scan', 'snapshot', 'selection', 'inspect'];

      function isContextTool(command) {
        const c = (command || '').toLowerCase();
        if (TOOL_COPY_OVERRIDES[c] && TOOL_COPY_OVERRIDES[c].toLowerCase().includes('context')) return true;
        return CONTEXT_TOOL_HINTS.some((hint) => c.includes(hint));
      }

      function humanizeToolAction(command) {
        if (!command) return 'Running toolâ€¦';
        const c = (command || '').toLowerCase();
        if (TOOL_COPY_OVERRIDES[c]) return TOOL_COPY_OVERRIDES[c];
        const words = c.replace(/[_-]+/g, ' ').split(' ').filter(Boolean);
        if (words.length === 0) return 'Running toolâ€¦';
        const verb = words[0];
        const rest = words.slice(1).join(' ');
        const ingMap = {
          'get': 'Getting',
          'fetch': 'Fetching',
          'scan': 'Scanning',
          'gather': 'Gathering',
          'update': 'Updating',
          'apply': 'Applying',
          'set': 'Setting',
          'rename': 'Renaming',
          'measure': 'Measuring',
          'analyze': 'Analyzing',
          'inspect': 'Inspecting',
          'create': 'Creating',
          'delete': 'Deleting',
          'find': 'Finding',
          'compute': 'Computing',
          'generate': 'Generating',
          'export': 'Exporting',
          'replace': 'Replacing'
        };
        if (ingMap[verb]) {
          return `${ingMap[verb]} ${rest || ''}`.trim() + 'â€¦';
        }
        return `Running ${words.join(' ')}â€¦`;
      }

      function createToolStatusLine(text) {
        const statusDiv = document.createElement('div');
        statusDiv.className = 'status-indicator';
        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        const statusText = document.createElement('div');
        statusText.className = 'status-text';
        statusText.textContent = text;
        statusDiv.appendChild(spinner);
        statusDiv.appendChild(statusText);
        chatContainer.appendChild(statusDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        return { el: statusDiv, spinnerEl: spinner, textEl: statusText, iconEl: null };
      }

      function completeToolStatusLine(line, ok) {
        if (!line || !line.el) return;
        try {
          if (line.spinnerEl && line.spinnerEl.parentNode) line.spinnerEl.remove();
          if (!line.iconEl) {
            const icon = document.createElement('div');
            icon.className = 'status-icon';
            icon.textContent = ok ? 'âœ…' : 'âŒ';
            line.el.insertBefore(icon, line.textEl);
            line.iconEl = icon;
          } else {
            line.iconEl.textContent = ok ? 'âœ…' : 'âŒ';
          }
        } catch (_) {}
      }

      function updateToolStatusLineTextById(id, text) {
        if (!id || !text) return;
        const entry = toolStatusLines.get(id);
        if (entry && entry.textEl) {
          entry.textEl.textContent = text;
          chatContainer.scrollTop = chatContainer.scrollHeight;
          return true;
        }
        if (contextGroup && contextGroup.open && contextGroup.pendingIds.has(id)) {
          if (contextGroup.line && contextGroup.line.textEl) {
            contextGroup.line.textEl.textContent = text;
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return true;
          }
        }
        return false;
      }

      function sanitizeAgentTextChunk(text) {
        if (!text) return text;
        try {
          // Remove common raw JSON payloads for tools/params
          const jsonLike = /\{[^{}]*\b(node_id|parent_id|params|types|width|height|x|y|r|g|b|a|radius|text|font_size|font_weight|layout_mode|name|smart_strategy|id)\b[^{}]*\}/g;
          let cleaned = text.replace(jsonLike, '').replace(/\s+/g, ' ');
          // Drop tool status chatter lines from model output
          const lines = cleaned.split(/\n+/).filter((ln) => {
            const l = ln.trim();
            if (!l) return false;
            if (/tool_called|step_succeeded|step_failed/i.test(l)) return false;
            if (/^([âœ…âŒðŸ› ï¸])/u.test(l)) return false;
            return true;
          });
          return lines.join('\n');
        } catch (_) {
          return text;
        }
      }

      function ensureContextGroup() {
        if (contextGroup && contextGroup.open) return contextGroup;
        const line = createToolStatusLine('Gathering contextâ€¦');
        contextGroup = { line, pendingIds: new Set(), failed: false, open: true, createdAt: Date.now() };
        return contextGroup;
      }

      function resolveContextTool(id, success) {
        if (!contextGroup || !contextGroup.open) return;
        contextGroup.pendingIds.delete(id);
        if (!success) contextGroup.failed = true;
        if (contextGroup.pendingIds.size === 0) {
          completeToolStatusLine(contextGroup.line, !contextGroup.failed);
          contextGroup.open = false;
          setTimeout(() => { contextGroup = null; }, 10000);
        }
      }

      function showError(message) {
        errorBanner.textContent = message;
        errorBanner.classList.add('show');
      }

      function hideError() {
        errorBanner.classList.remove('show');
      }

      function enableInput() {
        inputField.disabled = false;
        sendButton.disabled = false;
        inputField.placeholder = 'Message Fray...';
        inputField.focus();
      }

      function disableInput(placeholder = 'Connecting to server...') {
        inputField.disabled = true;
        sendButton.disabled = true;
        inputField.placeholder = placeholder;
        inputWrapper.classList.remove('has-content');
      }

      function updateConnectingUI(text = 'Connecting to bridge...') {
        disableInput(text);
        // Do not render a separate status line to avoid duplication with input placeholder
        removeStatusIndicator(true);
      }

      // Input behaviors
      function handleInputChange() {
        const text = inputField.value.trim();
        autoResizeTextarea();
        if (text.length > 0) {
          inputWrapper.classList.add('has-content');
        } else {
          inputWrapper.classList.remove('has-content');
        }
        if (text.length > 500) {
          inputWrapper.classList.add('show-counter');
          charCounter.textContent = `${text.length}/2000`;
        } else {
          inputWrapper.classList.remove('show-counter');
        }
      }

      function handleKeyDown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          handleSend();
        }
      }

      function autoResizeTextarea() {
        inputField.style.height = '52px';
        const newHeight = Math.min(inputField.scrollHeight, 200);
        inputField.style.height = newHeight + 'px';
      }

      async function handleSend() {
        const text = inputField.value.trim();
        if (!text || !state.connected || !state.socket) return;

        addMessage('user', text);
        inputField.value = '';
        autoResizeTextarea();
        inputWrapper.classList.remove('has-content');
        inputWrapper.classList.remove('show-counter');

        if (welcomeMessage) welcomeMessage.style.display = 'none';

        // Begin accepting a new stream for this prompt
        acceptingStream = true;
        currentStreamingContentEl = null;
        streamedAnyChunks = false;
        startNewAssistantBlockAfterTool = false;

        // No warmup selection traffic; selections are requested only when user sends

        // Build or reuse selections_context (30s TTL) keyed by selectionSignature
        async function requestSelectionsContextFromPlugin(mode = DEFAULT_SELECTIONS_MODE) {
          return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              window.removeEventListener('message', listener);
              reject(new Error('selections_context_timeout'));
            }, 6000);
            const listener = (event) => {
              const msg = event.data && event.data.pluginMessage;
              if (!msg) return;
              if (msg.type === 'selections_context') {
                clearTimeout(timeout);
                window.removeEventListener('message', listener);
                const result = msg.result;
                snapshotCache.lastSnapshot = { snapshot: result, mode, ts: Date.now() };
                snapshotCache.latestSig = (result && result.selectionSignature) || snapshotCache.latestSig;
                snapshotCache.document = (result && result.document) || snapshotCache.document;
                snapshotCache.last = {
                  selectionSignature: result.selectionSignature,
                  selectionSummary: result.selectionSummary,
                  document: result.document || snapshotCache.document || null,
                  ts: Date.now()
                };
                removeStatusIndicator(true);
                resolve(result);
              } else if (msg.type === 'selections_context_error') {
                clearTimeout(timeout);
                window.removeEventListener('message', listener);
                removeStatusIndicator(true);
                reject(new Error(msg.error || 'selections_context_error'));
              }
            };
            window.addEventListener('message', listener);
            parent.postMessage({ pluginMessage: { type: 'request_selections_context', mode } }, '*');
          });
        }

        let snapshot = undefined;
        const latestSig = snapshotCache.latestSig || (snapshotCache.last && snapshotCache.last.selectionSignature) || null;
        const haveExact = snapshotCache.lastSnapshot && snapshotCache.lastSnapshot.snapshot && (snapshotCache.lastSnapshot.snapshot.selectionSignature === latestSig) && (snapshotCache.lastSnapshot.mode === DEFAULT_SELECTIONS_MODE) && ((Date.now() - snapshotCache.lastSnapshot.ts) <= SNAPSHOT_TTL_MS);
        if (haveExact) {
          snapshot = snapshotCache.lastSnapshot.snapshot;
        } else {
          showStatusIndicator('Gathering contextâ€¦');
          try {
            snapshot = await requestSelectionsContextFromPlugin(DEFAULT_SELECTIONS_MODE);
          } catch (e) {
            // Proceed without snapshot on failure
          } finally {
            removeStatusIndicator(true);
          }
        }

        // Send to bridge
        const payload = snapshot ? { type: 'user_prompt', prompt: text, snapshot } : { type: 'user_prompt', prompt: text };
        state.socket.send(JSON.stringify(payload));

        // Show thinking status until streaming begins
        showStatusIndicator(getStatusMessage('thinking'));
      }


      // Bridge/WebSocket
      function generateChannelId() {
        return 'figma-copilot-default';
      }

      function connectToServer(port) {
        try {
          // Prevent duplicate connections or overlapping attempts
          if (isConnecting) return;
          if (state.socket && (state.socket.readyState === WebSocket.OPEN || state.socket.readyState === WebSocket.CONNECTING)) {
            return;
          }
          isConnecting = true;
          intentionalClose = false;
          state.serverPort = port;
          const ws = new WebSocket(`ws://localhost:${port}`);
          state.socket = ws;

          ws.onopen = () => {
            if (state.socket !== ws) return; // stale socket
            const channelId = generateChannelId();
            state.channel = channelId;
            ws.send(JSON.stringify({ type: 'join', role: 'plugin', channel: channelId }));
          };

          ws.onmessage = (event) => {
            if (state.socket !== ws) return; // stale socket
            try {
              const data = JSON.parse(event.data);
              if (data.type === 'system') {
                if (data.message && data.message.result) {
                  state.connected = true;
                  reconnectAttempts = 0;
                  if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
                  startHeartbeat();
                  hideError();
                  removeStatusIndicator();
                  enableInput();
                  isConnecting = false;
                  // Reset any orphaned stream state on fresh handshake
                  acceptingStream = false;
                  currentStreamingContentEl = null;
                } else if (typeof data.message === 'string') {
                  // Swallow model/tool status chatter injected as system lines
                  const msg = (data.message || '').trim();
                  if (/tool_called|step_succeeded|step_failed/i.test(msg) || /^([âœ…âŒðŸ› ï¸])/u.test(msg)) {
                    return;
                  }
                  // Otherwise show as assistant line
                  addMessage('assistant', msg);
                }
              } else if (data.type === 'agent_response_chunk') {
                if (!acceptingStream) {
                  // Ignore stale chunks from a previous session/request
                  return;
                }
                removeStatusIndicator(true);
                if (startNewAssistantBlockAfterTool) {
                  // Ensure following content appears after any tool status lines
                  currentStreamingContentEl = null;
                  startNewAssistantBlockAfterTool = false;
                }
                if (!currentStreamingContentEl) {
                  currentStreamingContentEl = addMessage('assistant', '');
                }
                const sanitized = sanitizeAgentTextChunk(data.chunk || '');
                if (sanitized) {
                  currentStreamingContentEl.textContent += sanitized;
                  streamedAnyChunks = true;
                }
                chatContainer.scrollTop = chatContainer.scrollHeight;
              } else if (data.type === 'agent_response') {
                if (!acceptingStream) {
                  // Ignore stray responses not tied to the current prompt
                  return;
                }
                const text = sanitizeAgentTextChunk(data.prompt || '');
                if (data.is_final) {
                  // If we streamed chunks already, don't overwrite; otherwise render final text
                  if (!streamedAnyChunks) {
                    if (!currentStreamingContentEl) {
                      currentStreamingContentEl = addMessage('assistant', '');
                    }
                    currentStreamingContentEl.textContent = text;
                  }
                  currentStreamingContentEl = null;
                  acceptingStream = false;
                  removeStatusIndicator(true);
                } else {
                  addMessage('assistant', text);
                }
              } else if (data.type === 'tool_call') {
                if (!acceptingStream) {
                  // Ignore tool calls initiated by a previous session/request
                  return;
                }
                const ts = new Date().toISOString();
                console.log(`[${ts}] tool_call`, data);
                const friendlyText = humanizeToolAction(data.command);
                if (isContextTool(data.command)) {
                  const group = ensureContextGroup();
                  group.pendingIds.add(data.id);
                } else {
                  const statusLine = createToolStatusLine(friendlyText);
                  toolStatusLines.set(data.id, { ...statusLine, command: data.command, type: 'single' });
                }
                // Ensure subsequent streamed text appears after this status line block
                if (acceptingStream) {
                  startNewAssistantBlockAfterTool = true;
                }
                parent.postMessage({ pluginMessage: { type: 'tool_call', id: data.id, command: data.command, params: data.params } }, '*');
              } else if (data.type === 'progress_update') {
                // Route progress updates into the existing muted status line, not separate chat messages
                const id = data.id || (data.message && data.message.id) || (data.message && data.message.commandId);
                const msg = (data.message && data.message.message) || (data.message && data.message.status) || 'Workingâ€¦';
                if (!updateToolStatusLineTextById(id, msg)) {
                  // If we cannot map to a specific tool line, fall back to a transient global indicator
                  showStatusIndicator(msg);
                }
              } else if (data.type === 'error') {
                showError(data.message || 'Bridge error');
                if (!state.connected) {
                  scheduleReconnect();
                }
              }
            } catch (err) {
              console.error('Message parse error', err);
            }
          };

          ws.onclose = () => {
            if (state.socket !== ws) return; // stale socket
            state.connected = false;
            state.socket = null;
            isConnecting = false;
            stopHeartbeat();
            acceptingStream = false;
            currentStreamingContentEl = null;
            removeStatusIndicator(true);
            if (!intentionalClose) {
              scheduleReconnect();
            }
          };

          ws.onerror = (error) => {
            if (state.socket !== ws) return; // stale socket
            console.error('WebSocket error:', error);
            state.connected = false;
            state.socket = null;
            isConnecting = false;
            stopHeartbeat();
            scheduleReconnect();
          };
        } catch (error) {
          console.error('Connection error:', error);
          scheduleReconnect(error.message);
        }
      }

      function getReconnectDelay(attempt) {
        return Math.min(BASE_RECONNECT_DELAY * Math.pow(2, Math.max(0, attempt - 1)), MAX_RECONNECT_DELAY);
      }

      function scheduleReconnect(errMessage) {
        if (state.connected) return;
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          showError(`Unable to connect to server after ${MAX_RECONNECT_ATTEMPTS} attempts`);
          updateConnectingUI('Unable to connect. Please try again later.');
          return;
        }
        reconnectAttempts += 1;
        const delay = getReconnectDelay(reconnectAttempts);
        const seconds = Math.round(delay / 1000);
        if (errMessage) {
          showError(`Connection error: ${errMessage}`);
        }
        updateConnectingUI(`Reconnectingâ€¦ (${seconds}s)`);
        if (reconnectTimer) clearTimeout(reconnectTimer);
        reconnectTimer = setTimeout(() => {
          // Ensure guard allows a fresh attempt
          isConnecting = false;
          connectToServer(state.serverPort);
        }, delay);
      }

      function startHeartbeat() {
        stopHeartbeat();
        heartbeatTimer = setInterval(() => {
          try {
            if (state.connected && state.socket && state.socket.readyState === WebSocket.OPEN) {
              // Send a lightweight no-op message to keep the connection active in some environments
              state.socket.send(JSON.stringify({ type: 'ping', t: Date.now() }));
            }
          } catch (e) {
            // If sending fails, trigger a reconnect path
            console.warn('Heartbeat send failed', e);
            try { state.socket && state.socket.close(); } catch (_) {}
          }
        }, HEARTBEAT_INTERVAL);
      }

      function stopHeartbeat() {
        if (heartbeatTimer) {
          clearInterval(heartbeatTimer);
          heartbeatTimer = null;
        }
      }
      function cleanupConnection(reason = 'cleanup') {
        intentionalClose = true;
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        stopHeartbeat();
        try { state.socket && state.socket.close(); } catch (_) {}
        state.socket = null;
        state.connected = false;
        acceptingStream = false;
        currentStreamingContentEl = null;
      }

      // Command/Tool plumbing retained
      function sendSuccessResponse(id, result) {
        if (!state.connected || !state.socket) return;
        state.socket.send(JSON.stringify({ id, type: 'message', channel: state.channel, message: { id, result } }));
      }

      function sendErrorResponse(id, errorMessage) {
        if (!state.connected || !state.socket) return;
        state.socket.send(JSON.stringify({ id, type: 'message', channel: state.channel, message: { id, error: errorMessage, result: {} } }));
      }

      function sendProgressUpdateToServer(progressData) {
        if (!state.connected || !state.socket) return;
        state.socket.send(JSON.stringify({ id: progressData.commandId, type: 'progress_update', channel: state.channel, message: { id: progressData.commandId, type: 'progress_update', data: progressData } }));
      }

      // Receive messages from plugin code
      window.onmessage = (event) => {
        const message = event.data.pluginMessage;
        if (!message) return;
        switch (message.type) {
          case 'document_info': {
            snapshotCache.document = { pageId: message.pageId, pageName: message.pageName };
            break;
          }
          case 'selection_summary': {
            // Keep latest selection signature so cache invalidates on selection change
            try {
              if (message.selectionSignature) {
                snapshotCache.latestSig = message.selectionSignature;
                snapshotCache.last = {
                  selectionSignature: message.selectionSignature,
                  selectionSummary: message.selectionSummary || null,
                  document: message.document || snapshotCache.document || null,
                  ts: Date.now()
                };
              }
            } catch (_) {}
            break;
          }
          
          case 'connection-status': {
            if (message.connected) {
              hideError();
              removeStatusIndicator();
              enableInput();
            } else {
              updateConnectingUI();
            }
            break;
          }
          case 'auto-connect': {
            // Guard to avoid duplicate connections if already open/connecting
            if (state.socket && (state.socket.readyState === WebSocket.OPEN || state.socket.readyState === WebSocket.CONNECTING)) {
            break;
            }
            if (isConnecting) break;
            updateConnectingUI();
            connectToServer(state.serverPort);
            break;
          }
          case 'auto-disconnect': {
            cleanupConnection('manual');
            break;
          }
          case 'command-result': {
            sendSuccessResponse(message.id, message.result);
            break;
          }
          case 'command-error': {
            sendErrorResponse(message.id, message.error);
            break;
          }
          case 'tool_response': {
            const ts = new Date().toISOString();
            console.log(`[${ts}] tool_response`, message);
            if (state.connected && state.socket) {
              const isFailure = message && message.result && typeof message.result === 'object' && message.result.success === false;
              const toolResponse = { type: 'tool_response', id: message.id };
              if (message.error || isFailure) {
                toolResponse.error = message.error || (message.result && message.result.message) || 'Tool reported failure';
              } else {
                toolResponse.result = message.result;
              }
              state.socket.send(JSON.stringify(toolResponse));
              const failed = Boolean(message.error) || Boolean(isFailure);
              if (contextGroup && contextGroup.open && contextGroup.pendingIds.has(message.id)) {
                resolveContextTool(message.id, !failed);
              } else {
                const entry = toolStatusLines.get(message.id);
                if (entry) {
                  completeToolStatusLine(entry, !failed);
                  setTimeout(() => { toolStatusLines.delete(message.id); }, 10000);
                }
              }
            }
            break;
          }
          case 'command_progress': {
            // Update the existing tool status line instead of creating a separate spinner
            const text = message.message || message.status || 'Workingâ€¦';
            const id = message.commandId || message.id;
            const updated = updateToolStatusLineTextById(id, text);
            sendProgressUpdateToServer(message);
            if (!updated && message.status === 'completed') {
              setTimeout(() => removeStatusIndicator(), 600);
            }
            break;
          }
        }
      };
    </script>
  </body>
</html>