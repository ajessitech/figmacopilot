<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fray - Figma Copilot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        font-size: 14px;
        color: #333;
        background: #f9fafb;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Chat Container */
      .chat-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px 24px;
        display: flex;
        flex-direction: column;
        background: #f9fafb;
        min-height: 0;
        scroll-behavior: smooth;
      }

      .chat-container::-webkit-scrollbar {
        width: 6px;
      }

      .chat-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .chat-container::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 3px;
      }

      /* Messages */
      .message {
        display: flex;
        animation: slideIn 0.3s ease-out;
        margin-bottom: 20px;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.user {
        justify-content: flex-end;
      }

      .message.assistant {
        justify-content: flex-start;
      }

      .message-content {
        line-height: 1.6;
        word-wrap: break-word;
      }

      /* User messages with bubble */
      .message.user .message-content {
        max-width: 75%;
        padding: 10px 14px;
        background: rgb(255, 120, 71);
        color: white;
        border-radius: 18px;
        border-bottom-right-radius: 4px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      /* Assistant messages without bubble - full width */
      .message.assistant .message-content {
        width: 100%;
        color: #1f2937;
        padding: 0;
        background: transparent;
        border: none;
        box-shadow: none;
      }

      /* Status indicator - minimal inline system style */
      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        margin: 8px 0;
        background: transparent;
        border-radius: 0;
        box-shadow: none;
        animation: slideInFade 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        transition: opacity 0.2s ease;
      }

      .status-indicator .spinner {
        width: 14px;
        height: 14px;
        min-width: 14px;
        border: 2px solid rgba(255, 120, 71, 0.25);
        border-top-color: rgb(255, 120, 71);
        border-radius: 50%;
        animation: spin 0.9s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }

      .status-indicator .status-text {
        color: #6b7280;
        font-size: 14px;
        font-weight: 500;
        letter-spacing: -0.01em;
        animation: fadeIn 0.3s ease-out;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .status-indicator .status-icon {
        font-size: 16px;
        line-height: 1;
      }

      @keyframes slideInFade {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Typing indicator */
      .typing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 8px 12px;
      }

      .typing-indicator span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: rgb(255, 120, 71);
        animation: typing 1.4s infinite;
      }

      .typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typing {
        0%, 60%, 100% {
          transform: translateY(0);
          opacity: 0.7;
        }
        30% {
          transform: translateY(-10px);
          opacity: 1;
        }
      }

      /* Welcome Message */
      .welcome-message {
        text-align: center;
        padding: 40px 20px;
        color: #666;
      }

      .welcome-message h2 {
        color: #333;
        margin-bottom: 12px;
        font-size: 20px;
      }

      .welcome-message p {
        line-height: 1.6;
        margin-bottom: 16px;
      }

      .tips {
        background: white;
        border: 1px solid #e5e5e5;
        border-radius: 8px;
        padding: 12px;
        text-align: left;
        font-size: 13px;
      }

      .tips h3 {
        color: rgb(255, 120, 71);
        margin-bottom: 10px;
        font-size: 15px;
        font-weight: 600;
      }

      .tips ul {
        list-style: none;
        padding-left: 0;
      }

      .tips li {
        padding: 4px 0;
        padding-left: 20px;
        position: relative;
      }

      .tips li::before {
        content: 'âœ¨';
        position: absolute;
        left: 0;
      }

      /* Input Area - Floating Style */
      .input-area {
        padding: 16px 24px 20px 24px;
        background: #f9fafb;
        flex-shrink: 0;
      }

      .input-container {
        max-width: 100%;
        margin: 0 auto;
        position: relative;
      }

      .input-wrapper {
        position: relative;
        background: #ffffff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 24px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        transition: all 0.2s ease;
      }

      .input-wrapper:hover {
        border-color: rgba(0, 0, 0, 0.12);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      }

      .input-wrapper:focus-within {
        border-color: rgba(255, 120, 71, 0.5);
        box-shadow: 0 2px 8px rgba(255, 120, 71, 0.1);
      }

      .input-field {
        width: 100%;
        min-height: 52px;
        max-height: 200px;
        padding: 14px 52px 14px 20px;
        border: none;
        background: transparent;
        resize: none;
        font-family: inherit;
        font-size: 15px;
        line-height: 1.6;
        color: #1f2937;
        overflow-y: auto;
      }

      .input-field:focus {
        outline: none;
      }

      .input-field::placeholder {
        color: #9ca3af;
        font-weight: 400;
        font-size: 15px;
      }

      .input-field:disabled {
        background: transparent;
        cursor: not-allowed;
        color: #9ca3af;
      }

      .input-field::-webkit-scrollbar {
        width: 6px;
      }

      .input-field::-webkit-scrollbar-track {
        background: transparent;
      }

      .input-field::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 3px;
      }

      .input-field::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
      }

      .send-button {
        position: absolute;
        right: 10px;
        bottom: 50%;
        transform: translateY(50%) scale(0.9);
        width: 36px;
        height: 36px;
        border: none;
        background: rgb(255, 120, 71);
        color: white;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        opacity: 0;
        pointer-events: none;
      }

      .input-wrapper.has-content .send-button {
        opacity: 1;
        transform: translateY(50%) scale(1);
        pointer-events: auto;
      }

      .send-button:hover:not(:disabled) {
        background: rgb(235, 100, 51);
        transform: translateY(50%) scale(1.1);
      }

      .send-button:active:not(:disabled) {
        transform: translateY(50%) scale(0.95);
      }

      .send-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        pointer-events: none;
      }

      .send-button svg {
        width: 18px;
        height: 18px;
        stroke-width: 2.5;
      }

      .char-counter {
        position: absolute;
        right: 48px;
        bottom: 14px;
        font-size: 11px;
        color: #9ca3af;
        display: none;
      }

      .input-wrapper.show-counter .char-counter {
        display: block;
      }

      .error-banner {
        background: #ffebee;
        color: #c62828;
        padding: 12px;
        border-radius: 6px;
        margin: 16px;
        margin-bottom: 0;
        display: none;
        animation: slideIn 0.3s ease-out;
        flex-shrink: 0;
      }

      .error-banner.show {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="error-banner" id="errorBanner"></div>

    <div class="chat-container" id="chatContainer">
      <div class="welcome-message" id="welcomeMessage">
        <h2>Welcome to Fray! ðŸ‘‹</h2>
        <p>I'm your AI-powered design assistant. Select elements in your Figma design and ask me questions about them.</p>
        <div class="tips">
          <h3>Try asking:</h3>
          <ul>
            <li>What are the dimensions of this frame?</li>
            <li>What colors are used in this selection?</li>
            <li>Describe the visual hierarchy</li>
            <li>What font is being used here?</li>
          </ul>
          </div>
        </div>
      </div>

    <div class="input-area">
      <div class="input-container">
        <div class="input-wrapper" id="inputWrapper">
          <textarea 
            class="input-field" 
            id="inputField" 
            placeholder="Message Fray..."
            rows="1"
            disabled
          ></textarea>
          <button class="send-button" id="sendButton" disabled>
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75"></path>
            </svg>
          </button>
          <span class="char-counter" id="charCounter"></span>
        </div>
      </div>
    </div>

    <script>
      // Connection state
      const state = {
        connected: false,
        socket: null,
        serverPort: 3055,
        pendingRequests: new Map(),
        channel: null,
      };

      // Reconnect/heartbeat config
      const HEARTBEAT_INTERVAL = 30000; // 30s
      const BASE_RECONNECT_DELAY = 3000; // 3s
      const MAX_RECONNECT_DELAY = 60000; // 60s
      const MAX_RECONNECT_ATTEMPTS = 7;
      let heartbeatTimer = null;
      let reconnectAttempts = 0;
      let reconnectTimer = null;
      let intentionalClose = false;
      let isConnecting = false;

      // DOM Elements
      let chatContainer, inputField, sendButton, errorBanner, welcomeMessage, inputWrapper, charCounter;

      // Streaming state
      let currentStreamingContentEl = null;
      let acceptingStream = false;

      // Status messages
      const statusMessages = {
        thinking: ['Thinking...', 'Working on it...', 'Considering your request...', 'Processing your idea...'],
        generating: ['Writing response...', 'Crafting your answer...', 'Putting it together...', 'Almost there...']
      };

      function getStatusMessage(category) {
        const messages = statusMessages[category];
        if (!messages) return 'Processing...';
        return messages[Math.floor(Math.random() * messages.length)];
      }

      document.addEventListener('DOMContentLoaded', () => {
        chatContainer = document.getElementById('chatContainer');
        inputField = document.getElementById('inputField');
        sendButton = document.getElementById('sendButton');
        errorBanner = document.getElementById('errorBanner');
        welcomeMessage = document.getElementById('welcomeMessage');
        inputWrapper = document.getElementById('inputWrapper');
        charCounter = document.getElementById('charCounter');

        // Events
        sendButton.addEventListener('click', handleSend);
        inputField.addEventListener('keydown', handleKeyDown);
        inputField.addEventListener('input', handleInputChange);

        // Auto-connect on load
        updateConnectingUI('Connecting to bridge...');
        connectToServer(state.serverPort);
        // Close socket on UI unload to avoid stale sessions
        window.addEventListener('beforeunload', () => cleanupConnection('unload'));
      });

      // UI helpers
      function addMessage(type, content) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message ' + (type === 'user' ? 'user' : 'assistant');

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.textContent = content || '';

        messageDiv.appendChild(contentDiv);
        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        return contentDiv;
      }

      function showStatusIndicator(text = 'Processing...') {
        removeStatusIndicator(true);
        const statusDiv = document.createElement('div');
        statusDiv.className = 'status-indicator';
        statusDiv.id = 'statusIndicator';

        const spinner = document.createElement('div');
        spinner.className = 'spinner';
        const statusText = document.createElement('div');
        statusText.className = 'status-text';
        statusText.textContent = text;

        statusDiv.appendChild(spinner);
        statusDiv.appendChild(statusText);
        chatContainer.appendChild(statusDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      function updateStatusText(text) {
        const statusIndicator = document.getElementById('statusIndicator');
        if (!statusIndicator) return;
        const statusText = statusIndicator.querySelector('.status-text');
        if (!statusText) return;
        statusText.style.opacity = '0';
        statusText.style.transition = 'opacity 0.15s ease-out';
        setTimeout(() => {
          statusText.textContent = text;
          statusText.style.opacity = '1';
          statusText.style.transition = 'opacity 0.2s ease-in';
        }, 150);
      }

      function removeStatusIndicator(immediate = false) {
        const el = document.getElementById('statusIndicator');
        if (!el) return;
        if (immediate) {
          el.remove();
          return;
        }
        el.style.opacity = '0';
        el.style.transition = 'opacity 0.2s ease-out';
        setTimeout(() => el.remove(), 200);
      }

      function showError(message) {
        errorBanner.textContent = message;
        errorBanner.classList.add('show');
      }

      function hideError() {
        errorBanner.classList.remove('show');
      }

      function enableInput() {
        inputField.disabled = false;
        sendButton.disabled = false;
        inputField.placeholder = 'Message Fray...';
        inputField.focus();
      }

      function disableInput(placeholder = 'Connecting to server...') {
        inputField.disabled = true;
        sendButton.disabled = true;
        inputField.placeholder = placeholder;
        inputWrapper.classList.remove('has-content');
      }

      function updateConnectingUI(text = 'Connecting to bridge...') {
        disableInput(text);
        // Do not render a separate status line to avoid duplication with input placeholder
        removeStatusIndicator(true);
      }

      // Input behaviors
      function handleInputChange() {
        const text = inputField.value.trim();
        autoResizeTextarea();
        if (text.length > 0) {
          inputWrapper.classList.add('has-content');
        } else {
          inputWrapper.classList.remove('has-content');
        }
        if (text.length > 500) {
          inputWrapper.classList.add('show-counter');
          charCounter.textContent = `${text.length}/2000`;
        } else {
          inputWrapper.classList.remove('show-counter');
        }
      }

      function handleKeyDown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          handleSend();
        }
      }

      function autoResizeTextarea() {
        inputField.style.height = '52px';
        const newHeight = Math.min(inputField.scrollHeight, 200);
        inputField.style.height = newHeight + 'px';
      }

      function handleSend() {
        const text = inputField.value.trim();
        if (!text || !state.connected || !state.socket) return;

        addMessage('user', text);
        inputField.value = '';
        autoResizeTextarea();
        inputWrapper.classList.remove('has-content');
        inputWrapper.classList.remove('show-counter');

        if (welcomeMessage) welcomeMessage.style.display = 'none';

        // Begin accepting a new stream for this prompt
        acceptingStream = true;
        currentStreamingContentEl = null;

        // Send to bridge
        state.socket.send(JSON.stringify({ type: 'user_prompt', prompt: text }));

        // Show thinking status until streaming begins
        showStatusIndicator(getStatusMessage('thinking'));
      }

      // Bridge/WebSocket
      function generateChannelId() {
        return 'figma-copilot-default';
      }

      function connectToServer(port) {
        try {
          // Prevent duplicate connections or overlapping attempts
          if (isConnecting) return;
          if (state.socket && (state.socket.readyState === WebSocket.OPEN || state.socket.readyState === WebSocket.CONNECTING)) {
            return;
          }
          isConnecting = true;
          intentionalClose = false;
          state.serverPort = port;
          const ws = new WebSocket(`ws://localhost:${port}`);
          state.socket = ws;

          ws.onopen = () => {
            if (state.socket !== ws) return; // stale socket
            const channelId = generateChannelId();
            state.channel = channelId;
            ws.send(JSON.stringify({ type: 'join', role: 'plugin', channel: channelId }));
          };

          ws.onmessage = (event) => {
            if (state.socket !== ws) return; // stale socket
            try {
              const data = JSON.parse(event.data);
              if (data.type === 'system') {
                if (data.message && data.message.result) {
                  state.connected = true;
                  reconnectAttempts = 0;
                  if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
                  startHeartbeat();
                  hideError();
                  removeStatusIndicator();
                  enableInput();
                  isConnecting = false;
                  // Reset any orphaned stream state on fresh handshake
                  acceptingStream = false;
                  currentStreamingContentEl = null;
                } else if (typeof data.message === 'string') {
                  addMessage('assistant', data.message);
                }
              } else if (data.type === 'agent_response_chunk') {
                if (!acceptingStream) {
                  // Ignore stale chunks from a previous session/request
                  return;
                }
                removeStatusIndicator(true);
                if (!currentStreamingContentEl) {
                  currentStreamingContentEl = addMessage('assistant', '');
                }
                currentStreamingContentEl.textContent += data.chunk || '';
                chatContainer.scrollTop = chatContainer.scrollHeight;
              } else if (data.type === 'agent_response') {
                if (!acceptingStream) {
                  // Ignore stray responses not tied to the current prompt
                  return;
                }
                const text = data.prompt || '';
                if (data.is_final) {
                  if (currentStreamingContentEl) {
                    currentStreamingContentEl.textContent = text;
                    currentStreamingContentEl = null;
                  }
                  acceptingStream = false;
                  removeStatusIndicator(true);
                } else {
                  addMessage('assistant', text);
                }
              } else if (data.type === 'tool_call') {
                if (!acceptingStream) {
                  // Ignore tool calls initiated by a previous session/request
                  return;
                }
                const ts = new Date().toISOString();
                console.log(`[${ts}] tool_call`, data);
                addMessage('assistant', `Executing: ${data.command} (ID: ${data.id})`);
                parent.postMessage({ pluginMessage: { type: 'tool_call', id: data.id, command: data.command, params: data.params } }, '*');
              } else if (data.type === 'error') {
                showError(data.message || 'Bridge error');
                if (!state.connected) {
                  scheduleReconnect();
                }
              }
            } catch (err) {
              console.error('Message parse error', err);
            }
          };

          ws.onclose = () => {
            if (state.socket !== ws) return; // stale socket
            state.connected = false;
            state.socket = null;
            isConnecting = false;
            stopHeartbeat();
            acceptingStream = false;
            currentStreamingContentEl = null;
            removeStatusIndicator(true);
            if (!intentionalClose) {
              scheduleReconnect();
            }
          };

          ws.onerror = (error) => {
            if (state.socket !== ws) return; // stale socket
            console.error('WebSocket error:', error);
            state.connected = false;
            state.socket = null;
            isConnecting = false;
            stopHeartbeat();
            scheduleReconnect();
          };
        } catch (error) {
          console.error('Connection error:', error);
          scheduleReconnect(error.message);
        }
      }

      function getReconnectDelay(attempt) {
        return Math.min(BASE_RECONNECT_DELAY * Math.pow(2, Math.max(0, attempt - 1)), MAX_RECONNECT_DELAY);
      }

      function scheduleReconnect(errMessage) {
        if (state.connected) return;
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          showError(`Unable to connect to server after ${MAX_RECONNECT_ATTEMPTS} attempts`);
          updateConnectingUI('Unable to connect. Please try again later.');
          return;
        }
        reconnectAttempts += 1;
        const delay = getReconnectDelay(reconnectAttempts);
        const seconds = Math.round(delay / 1000);
        if (errMessage) {
          showError(`Connection error: ${errMessage}`);
        }
        updateConnectingUI(`Reconnectingâ€¦ (${seconds}s)`);
        isConnecting = true;
        if (reconnectTimer) clearTimeout(reconnectTimer);
        reconnectTimer = setTimeout(() => {
          connectToServer(state.serverPort);
        }, delay);
      }

      function startHeartbeat() {
        stopHeartbeat();
        heartbeatTimer = setInterval(() => {
          try {
            if (state.connected && state.socket && state.socket.readyState === WebSocket.OPEN) {
              // Send a lightweight no-op message to keep the connection active in some environments
              state.socket.send(JSON.stringify({ type: 'ping', t: Date.now() }));
            }
          } catch (e) {
            // If sending fails, trigger a reconnect path
            console.warn('Heartbeat send failed', e);
            try { state.socket && state.socket.close(); } catch (_) {}
          }
        }, HEARTBEAT_INTERVAL);
      }

      function stopHeartbeat() {
        if (heartbeatTimer) {
          clearInterval(heartbeatTimer);
          heartbeatTimer = null;
        }
      }
      function cleanupConnection(reason = 'cleanup') {
        intentionalClose = true;
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        stopHeartbeat();
        try { state.socket && state.socket.close(); } catch (_) {}
        state.socket = null;
        state.connected = false;
        acceptingStream = false;
        currentStreamingContentEl = null;
      }

      // Command/Tool plumbing retained
      function sendSuccessResponse(id, result) {
        if (!state.connected || !state.socket) return;
        state.socket.send(JSON.stringify({ id, type: 'message', channel: state.channel, message: { id, result } }));
      }

      function sendErrorResponse(id, errorMessage) {
        if (!state.connected || !state.socket) return;
        state.socket.send(JSON.stringify({ id, type: 'message', channel: state.channel, message: { id, error: errorMessage, result: {} } }));
      }

      function sendProgressUpdateToServer(progressData) {
        if (!state.connected || !state.socket) return;
        state.socket.send(JSON.stringify({ id: progressData.commandId, type: 'progress_update', channel: state.channel, message: { id: progressData.commandId, type: 'progress_update', data: progressData } }));
      }

      // Receive messages from plugin code
      window.onmessage = (event) => {
        const message = event.data.pluginMessage;
        if (!message) return;
        switch (message.type) {
          case 'connection-status': {
            if (message.connected) {
              hideError();
              removeStatusIndicator();
              enableInput();
            } else {
              updateConnectingUI();
            }
            break;
          }
          case 'auto-connect': {
            // Guard to avoid duplicate connections if already open/connecting
            if (state.socket && (state.socket.readyState === WebSocket.OPEN || state.socket.readyState === WebSocket.CONNECTING)) {
            break;
            }
            if (isConnecting) break;
            updateConnectingUI();
            connectToServer(state.serverPort);
            break;
          }
          case 'auto-disconnect': {
            cleanupConnection('manual');
            break;
          }
          case 'command-result': {
            sendSuccessResponse(message.id, message.result);
            break;
          }
          case 'command-error': {
            sendErrorResponse(message.id, message.error);
            break;
          }
          case 'tool_response': {
            const ts = new Date().toISOString();
            console.log(`[${ts}] tool_response`, message);
            if (state.connected && state.socket) {
              const toolResponse = { type: 'tool_response', id: message.id, result: message.result, error: message.error };
              state.socket.send(JSON.stringify(toolResponse));
              if (message.error) {
                showError(`Tool failed: ${message.error}`);
              } else {
                addMessage('assistant', `Tool completed (ID: ${message.id})`);
              }
            }
            break;
          }
          case 'command_progress': {
            // Map progress to status indicator
            const text = message.message || 'Operation in progress';
            showStatusIndicator(text);
            sendProgressUpdateToServer(message);
            if (message.status === 'completed') {
              setTimeout(() => removeStatusIndicator(), 600);
            }
            break;
          }
        }
      };
    </script>
  </body>
</html>